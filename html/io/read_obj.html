
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>read_obj</title><meta name="generator" content="MATLAB 8.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-04-04"><meta name="DC.source" content="read_obj.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>read_obj</h1><!--introduction--><p>Read mesh data from wavefront OBJ format file, only triangle mesh supported.</p><p>Data supported are:</p><div><ul><li>geometric vertices (v)</li><li>texture vertices (vt)</li><li>vertex normals (vn)</li><li>face (f) (triangle only)</li></ul></div><p>All other data will be disgarded.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example</a></li><li><a href="#4">Contribution</a></li></ul></div><h2>Syntax<a name="1"></a></h2><pre class="language-matlab">[face,vertex] = read_obj(filename)
[face,vertex,extra] = read_obj(filename)
</pre><h2>Description<a name="2"></a></h2><pre>filename: string, file to read.</pre><pre>face  : double array, nf x 3, connectivity of the mesh.
vertex: double array, nv x 3, position of the vertices.
extra : struct, anything other than face and vertex are included.</pre><h2>Example<a name="3"></a></h2><pre class="language-matlab">[face,vertex] = read_obj(<span class="string">'cube.obj'</span>);
[face,vertex,extra] = read_obj(<span class="string">'face.obj'</span>);
</pre><h2>Contribution<a name="4"></a></h2><pre>Author : Wen Cheng Feng
Created: 2014/03/26</pre><pre>Copyright 2014 Computational Geometry Group
Department of Mathematics, CUHK
http://www.lokminglui.com</pre><pre class="codeinput"><span class="keyword">function</span> [face,vertex,extra] = read_obj(filename)
<span class="comment">% read whole file into a string</span>
text = fileread(filename);
<span class="comment">% split text into lines</span>
[~,lines] = regexp(text,<span class="string">'\n'</span>,<span class="string">'match'</span>,<span class="string">'split'</span>);
<span class="comment">% remove empty and comment lines</span>
ind = cellfun(@(s) isempty(s) || strcmp(s(1),char(13)) || strcmp(s(1),<span class="string">'#'</span>),lines);
lines(ind) = [];

<span class="comment">% find all face lines that start with 'f'</span>
ind = cellfun(@(s) strcmp(s(1),<span class="string">'f'</span>),lines);
face_lines = lines(ind);
lines(ind) = [];
<span class="comment">% determine format of face line</span>
[type,format,sz] = get_format(face_lines{1});
<span class="comment">% join face lines to a string</span>
face_string = strjoin(face_lines,<span class="string">'\n'</span>);
<span class="comment">% scan face from string</span>
face = sscanf(face_string,format);
face = reshape(face,sz,length(face)/sz)';

<span class="comment">% find all vertex lines that start with 'v'</span>
ind = cellfun(@(s) strcmp(s(1:2),<span class="string">'v '</span>),lines);
vertex_lines = lines(ind);
lines(ind) = [];
<span class="comment">% determint format of vertex line</span>
[type,format,sz] = get_format(vertex_lines{1});
<span class="comment">% join vertex lines to a string</span>
vertex_string = strjoin(vertex_lines,<span class="string">'\n'</span>);
<span class="comment">% scan vertex from string</span>
vertex = sscanf(vertex_string,format);
vertex = reshape(vertex,sz,length(vertex)/sz)';

<span class="comment">% put all other stuff into a structure extra</span>
extra = [];
<span class="keyword">if</span> size(vertex,2) &gt; 3
    <span class="comment">% if vertex line have more than 3 number, then it's color</span>
    vertex_color = vertex(:,4:end);
    vertex = vertex(:,1:3);
    extra.vertex_color = vertex_color;
<span class="keyword">end</span>

<span class="comment">% check if texture and normal are contained</span>
texture = [];
normal = [];
ind = cellfun(@(s) strcmp(s(1:2),<span class="string">'vt'</span>),lines);
texture_lines = lines(ind);
lines(ind) = [];
<span class="keyword">if</span> sum(ind)
    texture_string = strjoin(texture_lines,<span class="string">'\n'</span>);
    [type,format,sz] = get_format(texture_lines{1});
    texture = sscanf(texture_string,format);
    texture = reshape(texture,sz,length(texture)/sz)';
    extra.texture = texture;
<span class="keyword">end</span>
ind = cellfun(@(s) strcmp(s(1:2),<span class="string">'vn'</span>),lines);
normal_lines = lines(ind);
<span class="keyword">if</span> sum(ind)
    normal_string = strjoin(normal_lines,<span class="string">'\n'</span>);
    [type,format,sz] = get_format(normal_lines{1});
    normal = sscanf(normal_string,format);
    normal = reshape(normal,sz,length(normal)/sz)';
    extra.normal = normal;
<span class="keyword">end</span>

<span class="comment">% if texture or normal contained, retrive face_texture and face_normal from</span>
<span class="comment">% face array</span>
<span class="keyword">if</span> ~isempty(texture) &amp;&amp; ~isempty(normal)
    face_texture = face(:,[2 5 8]);
    face_normal = face(:,[3 6 9]);
    face = face(:,[1 4 7]);
    extra.face_texture = face_texture;
    extra.face_normal = face_normal;
<span class="keyword">elseif</span> ~isempty(texture) &amp;&amp; isempty(normal)
    face_texture = face(:,[2 4 6]);
    face = face(:,[1 3 5]);
    extra.face_texture = face_texture;
<span class="keyword">elseif</span> isempty(texture) &amp;&amp; ~isempty(normal)
    face_normal = face(:,[2 4 6]);
    face = face(:,[1 3 5]);
    extra.face_normal = face_normal;
<span class="keyword">end</span>

<span class="keyword">function</span> [type,format,sz] = get_format(str)
<span class="comment">% determine the format of input str</span>
sn = <span class="string">'[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)'</span>; <span class="comment">% match number</span>
ss = <span class="string">'[a-zA-Z]+'</span>; <span class="comment">% match string</span>
format = regexprep(str,sn,<span class="string">'%f'</span>);
<span class="keyword">if</span> format(end) ~= char(13)
    format = [format,<span class="string">'\n'</span>];
<span class="keyword">end</span>
[type,~] = regexp(str,ss,<span class="string">'match'</span>);
type = type{1};
[~,splitstr] = regexp(str,sn,<span class="string">'match'</span>);
sz = length(splitstr);
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% read_obj 
% Read mesh data from wavefront OBJ format file, only triangle mesh supported. 
% 
% Data supported are:
% 
% * geometric vertices (v)
% * texture vertices (vt)
% * vertex normals (vn)
% * face (f) (triangle only)
%
% All other data will be disgarded.

%% Syntax
%   [face,vertex] = read_obj(filename)
%   [face,vertex,extra] = read_obj(filename)
%
%% Description
%  filename: string, file to read.
%
%  face  : double array, nf x 3, connectivity of the mesh.
%  vertex: double array, nv x 3, position of the vertices.
%  extra : struct, anything other than face and vertex are included.
%
%% Example
%   [face,vertex] = read_obj('cube.obj');
%   [face,vertex,extra] = read_obj('face.obj');
%
%% Contribution
%  Author : Wen Cheng Feng
%  Created: 2014/03/26
% 
%  Copyright 2014 Computational Geometry Group
%  Department of Mathematics, CUHK
%  http://www.lokminglui.com

function [face,vertex,extra] = read_obj(filename)
% read whole file into a string
text = fileread(filename);
% split text into lines
[~,lines] = regexp(text,'\n','match','split');
% remove empty and comment lines
ind = cellfun(@(s) isempty(s) || strcmp(s(1),char(13)) || strcmp(s(1),'#'),lines);
lines(ind) = [];

% find all face lines that start with 'f'
ind = cellfun(@(s) strcmp(s(1),'f'),lines);
face_lines = lines(ind);
lines(ind) = [];
% determine format of face line
[type,format,sz] = get_format(face_lines{1});
% join face lines to a string
face_string = strjoin(face_lines,'\n');
% scan face from string
face = sscanf(face_string,format);
face = reshape(face,sz,length(face)/sz)';

% find all vertex lines that start with 'v'
ind = cellfun(@(s) strcmp(s(1:2),'v '),lines);
vertex_lines = lines(ind);
lines(ind) = [];
% determint format of vertex line
[type,format,sz] = get_format(vertex_lines{1});
% join vertex lines to a string
vertex_string = strjoin(vertex_lines,'\n');
% scan vertex from string
vertex = sscanf(vertex_string,format);
vertex = reshape(vertex,sz,length(vertex)/sz)';

% put all other stuff into a structure extra
extra = [];
if size(vertex,2) > 3
    % if vertex line have more than 3 number, then it's color
    vertex_color = vertex(:,4:end);
    vertex = vertex(:,1:3);
    extra.vertex_color = vertex_color;
end

% check if texture and normal are contained
texture = [];
normal = [];
ind = cellfun(@(s) strcmp(s(1:2),'vt'),lines);
texture_lines = lines(ind);
lines(ind) = [];
if sum(ind)
    texture_string = strjoin(texture_lines,'\n');
    [type,format,sz] = get_format(texture_lines{1});
    texture = sscanf(texture_string,format);
    texture = reshape(texture,sz,length(texture)/sz)';
    extra.texture = texture;
end
ind = cellfun(@(s) strcmp(s(1:2),'vn'),lines);
normal_lines = lines(ind);
if sum(ind)
    normal_string = strjoin(normal_lines,'\n');
    [type,format,sz] = get_format(normal_lines{1});
    normal = sscanf(normal_string,format);
    normal = reshape(normal,sz,length(normal)/sz)';
    extra.normal = normal;
end

% if texture or normal contained, retrive face_texture and face_normal from
% face array
if ~isempty(texture) && ~isempty(normal)
    face_texture = face(:,[2 5 8]);
    face_normal = face(:,[3 6 9]);
    face = face(:,[1 4 7]);
    extra.face_texture = face_texture;
    extra.face_normal = face_normal;
elseif ~isempty(texture) && isempty(normal)
    face_texture = face(:,[2 4 6]);
    face = face(:,[1 3 5]);
    extra.face_texture = face_texture;
elseif isempty(texture) && ~isempty(normal)
    face_normal = face(:,[2 4 6]);
    face = face(:,[1 3 5]);
    extra.face_normal = face_normal;
end

function [type,format,sz] = get_format(str)
% determine the format of input str
sn = '[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)'; % match number
ss = '[a-zA-Z]+'; % match string
format = regexprep(str,sn,'%f');
if format(end) ~= char(13)
    format = [format,'\n'];
end
[type,~] = regexp(str,ss,'match');
type = type{1};
[~,splitstr] = regexp(str,sn,'match');
sz = length(splitstr);

##### SOURCE END #####
--></body></html>